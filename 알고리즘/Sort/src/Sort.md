# 정렬 알고리즘 비교 (개념별)

| 개념                  | **Selection Sort**                          | **Bubble Sort**                            | **Insertion Sort**                        | **Shell Sort**                            | **Quick Sort**                            | **Merge Sort**                            | **Heap Sort**                            | **Radix Sort**                            | **Counting Sort**                        |
|-----------------------|---------------------------------------------|--------------------------------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|------------------------------------------|-------------------------------------------|------------------------------------------|
| **설명**              | 배열에서 최소값을 찾아 맨 앞부터 배치        | 인접 요소 비교 후 교환하며 큰 값을 끝으로 이동 | 카드를 정렬하듯 요소를 하나씩 삽입         | 간격을 두고 삽입 정렬을 수행하며 간격 축소 | Pivot을 기준으로 분할 후 재귀 정렬         | 배열을 반으로 나누어 정렬 후 병합          | 힙을 이용해 최대/최소값 추출 후 정렬      | 각 자릿수를 기준으로 비비교 정렬          | 값 범위를 카운트하여 위치 계산 후 정렬    |
| **시간 복잡도**       | \(O(n^2)\) / \(O(n^2)\) / \(O(n^2)\)       | \(O(n)\) / \(O(n^2)\) / \(O(n^2)\)        | \(O(n)\) / \(O(n^2)\) / \(O(n^2)\)       | \(O(n)\) / \(O(n^{1.3})\) / \(O(n^2)\)   | \(O(n \log n)\) / \(O(n \log n)\) / \(O(n^2)\) | \(O(n \log n)\) / \(O(n \log n)\) / \(O(n \log n)\) | \(O(n \log n)\) / \(O(n \log n)\) / \(O(n \log n)\) | \(O(nk)\) / \(O(nk)\) / \(O(nk)\) (k: 자릿수) | \(O(n + k)\) / \(O(n + k)\) / \(O(n + k)\) (k: 값 범위) |
| **공간 복잡도**       | \(O(1)\)                                   | \(O(1)\)                                  | \(O(1)\)                                 | \(O(1)\)                                 | \(O(\log n)\) ~ \(O(n)\)                 | \(O(n)\)                                 | \(O(1)\)                                | \(O(n + k)\)                             | \(O(n + k)\)                            |
| **장점**              | 구현 간단, 제자리 정렬                      | 간단, 안정적, 최적화 가능                  | 안정적, 적응적(정렬된 경우 빠름)          | 삽입 정렬보다 빠름, 제자리 정렬            | 평균적으로 매우 빠름, 제자리 정렬          | 안정적, 최악에도 일정 성능                | 제자리 정렬, 일정 성능 보장              | 비비교 방식으로 빠름, 선형 시간 가능       | 선형 시간, 비비교 방식                  |
| **단점**              | 비효율적, 안정적이지 않음                   | 매우 느림, 대규모 데이터에 부적합           | 대규모 데이터에서 비효율적                 | 복잡도 분석 어려움, 안정적이지 않음        | 최악의 경우 느림, 안정적이지 않음          | 추가 메모리 필요, 제자리 정렬 아님        | 구현 복잡, 캐시 활용 비효율적            | 정수/문자열만 가능, 추가 메모리 필요       | 값 범위가 작아야 효율적, 메모리 소모 큼  |
| **적합한 케이스**     | 소규모 데이터, 단순 구현 필요 시             | 소규모/거의 정렬된 데이터, 학습용           | 소규모/부분 정렬된 데이터, 온라인 정렬      | 중간 규모 데이터, 삽입 정렬 개선 필요 시     | 대규모/랜덤 데이터, 코딩 테스트            | 대규모 데이터, 안정성 필요한 경우          | 메모리 제약 환경, 우선순위 큐 응용        | 큰 정수/고정 길이 문자열 정렬             | 값 범위가 제한된 정수 정렬              |

## 비고
- **Selection Sort**: 최소값을 반복적으로 찾아 정렬, 단순하지만 비효율적.
- **Bubble Sort**: 느리지만 최적화로 조기 종료 가능.
- **Insertion Sort**: 실시간 데이터 삽입(온라인 알고리즘)에 유리.
- **Shell Sort**: 간격 설정에 따라 성능 변동, 중간 규모에 적합.
- **Quick Sort**: Pivot 선택이 성능 좌우, 실무에서 널리 사용.
- **Merge Sort**: 외부 정렬(디스크 기반)에도 활용 가능.
- **Heap Sort**: 힙 구축 후 정렬, 메모리 효율적.
- **Radix Sort**: LSD(최하위 자릿수) 또는 MSD(최상위 자릿수) 방식 사용.
- **Counting Sort**: 범위가 작을수록 강력, 분포 기반 정렬.